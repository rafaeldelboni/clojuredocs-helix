[{"arglist-strs":["[s]"],"doc":"Returns s with its characters reversed.","end-row":52,"filename":"clojure/string.clj","fixed-arities":[1],"name":"reverse","ns":"clojure.string","row":48},{"arglist-strs":["[replacement]"],"doc":"Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.","end-row":60,"filename":"clojure/string.clj","fixed-arities":[1],"name":"re-quote-replacement","ns":"clojure.string","row":54},{"arglist-strs":["[s re f]"],"end-row":73,"filename":"clojure/string.clj","fixed-arities":[3],"name":"replace-by","ns":"clojure.string","private":true,"row":62},{"arglist-strs":["[s match replacement]"],"doc":"Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"","end-row":109,"filename":"clojure/string.clj","fixed-arities":[3],"name":"replace","ns":"clojure.string","row":75},{"arglist-strs":["[s re f]"],"end-row":120,"filename":"clojure/string.clj","fixed-arities":[3],"name":"replace-first-by","ns":"clojure.string","private":true,"row":111},{"arglist-strs":["[s match replace]"],"end-row":128,"filename":"clojure/string.clj","fixed-arities":[3],"name":"replace-first-char","ns":"clojure.string","private":true,"row":122},{"arglist-strs":["[s match replace]"],"end-row":136,"filename":"clojure/string.clj","fixed-arities":[3],"name":"replace-first-str","ns":"clojure.string","private":true,"row":130},{"arglist-strs":["[s match replacement]"],"doc":"Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"","end-row":177,"filename":"clojure/string.clj","fixed-arities":[3],"name":"replace-first","ns":"clojure.string","row":138},{"arglist-strs":["[coll]","[separator coll]"],"doc":"Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.","end-row":194,"filename":"clojure/string.clj","fixed-arities":[1,2],"name":"join","ns":"clojure.string","row":180},{"arglist-strs":["[s]"],"doc":"Converts first character of the string to upper-case, all other\n  characters to lower-case.","end-row":205,"filename":"clojure/string.clj","fixed-arities":[1],"name":"capitalize","ns":"clojure.string","row":196},{"arglist-strs":["[s]"],"doc":"Converts string to all upper-case.","end-row":211,"filename":"clojure/string.clj","fixed-arities":[1],"name":"upper-case","ns":"clojure.string","row":207},{"arglist-strs":["[s]"],"doc":"Converts string to all lower-case.","end-row":217,"filename":"clojure/string.clj","fixed-arities":[1],"name":"lower-case","ns":"clojure.string","row":213},{"arglist-strs":["[s re]","[s re limit]"],"doc":"Splits string on a regular expression.  Optional argument limit is\n  the maximum number of parts. Not lazy. Returns vector of the parts.\n  Trailing empty strings are not returned - pass limit of -1 to return all.","end-row":227,"filename":"clojure/string.clj","fixed-arities":[3,2],"name":"split","ns":"clojure.string","row":219},{"arglist-strs":["[s]"],"doc":"Splits s on \\n or \\r\\n. Trailing empty lines are not returned.","end-row":233,"filename":"clojure/string.clj","fixed-arities":[1],"name":"split-lines","ns":"clojure.string","row":229},{"arglist-strs":["[s]"],"doc":"Removes whitespace from both ends of string.","end-row":250,"filename":"clojure/string.clj","fixed-arities":[1],"name":"trim","ns":"clojure.string","row":235},{"arglist-strs":["[s]"],"doc":"Removes whitespace from the left side of string.","end-row":262,"filename":"clojure/string.clj","fixed-arities":[1],"name":"triml","ns":"clojure.string","row":252},{"arglist-strs":["[s]"],"doc":"Removes whitespace from the right side of string.","end-row":273,"filename":"clojure/string.clj","fixed-arities":[1],"name":"trimr","ns":"clojure.string","row":264},{"arglist-strs":["[s]"],"doc":"Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.","end-row":286,"filename":"clojure/string.clj","fixed-arities":[1],"name":"trim-newline","ns":"clojure.string","row":275},{"arglist-strs":["[s]"],"doc":"True if s is nil, empty, or contains only whitespace.","end-row":299,"filename":"clojure/string.clj","fixed-arities":[1],"name":"blank?","ns":"clojure.string","row":288},{"arglist-strs":["[s cmap]"],"doc":"Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.","end-row":317,"filename":"clojure/string.clj","fixed-arities":[2],"name":"escape","ns":"clojure.string","row":301},{"arglist-strs":["[s value]","[s value from-index]"],"doc":"Return index of value (string or char) in s, optionally searching\n  forward from from-index. Return nil if value not found.","end-row":338,"filename":"clojure/string.clj","fixed-arities":[3,2],"name":"index-of","ns":"clojure.string","row":319},{"arglist-strs":["[s value]","[s value from-index]"],"doc":"Return last index of value (string or char) in s, optionally\n  searching backward from from-index. Return nil if value not found.","end-row":359,"filename":"clojure/string.clj","fixed-arities":[3,2],"name":"last-index-of","ns":"clojure.string","row":340},{"arglist-strs":["[s substr]"],"doc":"True if s starts with substr.","end-row":365,"filename":"clojure/string.clj","fixed-arities":[2],"name":"starts-with?","ns":"clojure.string","row":361},{"arglist-strs":["[s substr]"],"doc":"True if s ends with substr.","end-row":371,"filename":"clojure/string.clj","fixed-arities":[2],"name":"ends-with?","ns":"clojure.string","row":367},{"arglist-strs":["[s substr]"],"doc":"True if s includes substr.","end-row":377,"filename":"clojure/string.clj","fixed-arities":[2],"name":"includes?","ns":"clojure.string","row":373}]