[{"fixed-arities":[1],"end-row":52,"meta":{},"name-end-col":22,"name-end-row":48,"name-row":48,"added":"1.2","ns":"clojure.string","name":"reverse","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L48","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":45,"arglist-strs":["[s]"],"doc":"Returns s with its characters reversed.","row":48},{"fixed-arities":[1],"end-row":60,"meta":{},"name-end-col":35,"name-end-row":54,"name-row":54,"added":"1.5","ns":"clojure.string","name":"re-quote-replacement","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L54","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":68,"arglist-strs":["[replacement]"],"doc":"Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.","row":54},{"fixed-arities":[3],"end-row":73,"meta":{},"name-end-col":18,"name-end-row":62,"private":true,"name-row":62,"ns":"clojure.string","name":"replace-by","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L62","filename":"/src/clj/clojure/string.clj","col":1,"name-col":8,"end-col":11,"arglist-strs":["[s re f]"],"row":62},{"fixed-arities":[3],"end-row":109,"meta":{},"name-end-col":22,"name-end-row":75,"name-row":75,"added":"1.2","ns":"clojure.string","name":"replace","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L75","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":84,"arglist-strs":["[s match replacement]"],"doc":"Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"","row":75},{"fixed-arities":[3],"end-row":120,"meta":{},"name-end-col":24,"name-end-row":111,"private":true,"name-row":111,"ns":"clojure.string","name":"replace-first-by","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L111","filename":"/src/clj/clojure/string.clj","col":1,"name-col":8,"end-col":11,"arglist-strs":["[s re f]"],"row":111},{"fixed-arities":[3],"end-row":128,"meta":{},"name-end-col":26,"name-end-row":122,"private":true,"name-row":122,"ns":"clojure.string","name":"replace-first-char","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L122","filename":"/src/clj/clojure/string.clj","col":1,"name-col":8,"end-col":53,"arglist-strs":["[s match replace]"],"row":122},{"fixed-arities":[3],"end-row":136,"meta":{},"name-end-col":25,"name-end-row":130,"private":true,"name-row":130,"ns":"clojure.string","name":"replace-first-str","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L130","filename":"/src/clj/clojure/string.clj","col":1,"name-col":8,"end-col":67,"arglist-strs":["[s match replace]"],"row":130},{"fixed-arities":[3],"end-row":177,"meta":{},"name-end-col":28,"name-end-row":138,"name-row":138,"added":"1.2","ns":"clojure.string","name":"replace-first","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L138","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":84,"arglist-strs":["[s match replacement]"],"doc":"Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"","row":138},{"fixed-arities":[1,2],"end-row":194,"meta":{},"name-end-col":19,"name-end-row":180,"name-row":180,"added":"1.2","ns":"clojure.string","name":"join","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L180","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":22,"arglist-strs":["[coll]","[separator coll]"],"doc":"Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.","row":180},{"fixed-arities":[1],"end-row":205,"meta":{},"name-end-col":25,"name-end-row":196,"name-row":196,"added":"1.2","ns":"clojure.string","name":"capitalize","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L196","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":41,"arglist-strs":["[s]"],"doc":"Converts first character of the string to upper-case, all other\n  characters to lower-case.","row":196},{"fixed-arities":[1],"end-row":211,"meta":{},"name-end-col":25,"name-end-row":207,"name-row":207,"added":"1.2","ns":"clojure.string","name":"upper-case","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L207","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":31,"arglist-strs":["[s]"],"doc":"Converts string to all upper-case.","row":207},{"fixed-arities":[1],"end-row":217,"meta":{},"name-end-col":25,"name-end-row":213,"name-row":213,"added":"1.2","ns":"clojure.string","name":"lower-case","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L213","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":31,"arglist-strs":["[s]"],"doc":"Converts string to all lower-case.","row":213},{"fixed-arities":[3,2],"end-row":227,"meta":{},"name-end-col":12,"name-end-row":219,"name-row":219,"added":"1.2","ns":"clojure.string","name":"split","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L219","filename":"/src/clj/clojure/string.clj","col":1,"name-col":7,"end-col":65,"arglist-strs":["[s re]","[s re limit]"],"doc":"Splits string on a regular expression.  Optional argument limit is\n  the maximum number of parts. Not lazy. Returns vector of the parts.\n  Trailing empty strings are not returned - pass limit of -1 to return all.","row":219},{"fixed-arities":[1],"end-row":233,"meta":{},"name-end-col":18,"name-end-row":229,"name-row":229,"added":"1.2","ns":"clojure.string","name":"split-lines","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L229","filename":"/src/clj/clojure/string.clj","col":1,"name-col":7,"end-col":22,"arglist-strs":["[s]"],"doc":"Splits s on \\n or \\r\\n. Trailing empty lines are not returned.","row":229},{"fixed-arities":[1],"end-row":250,"meta":{},"name-end-col":19,"name-end-row":235,"name-row":235,"added":"1.2","ns":"clojure.string","name":"trim","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L235","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":65,"arglist-strs":["[s]"],"doc":"Removes whitespace from both ends of string.","row":235},{"fixed-arities":[1],"end-row":262,"meta":{},"name-end-col":20,"name-end-row":252,"name-row":252,"added":"1.2","ns":"clojure.string","name":"triml","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L252","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":55,"arglist-strs":["[s]"],"doc":"Removes whitespace from the left side of string.","row":252},{"fixed-arities":[1],"end-row":273,"meta":{},"name-end-col":20,"name-end-row":264,"name-row":264,"added":"1.2","ns":"clojure.string","name":"trimr","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L264","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":50,"arglist-strs":["[s]"],"doc":"Removes whitespace from the right side of string.","row":264},{"fixed-arities":[1],"end-row":286,"meta":{},"name-end-col":27,"name-end-row":275,"name-row":275,"added":"1.2","ns":"clojure.string","name":"trim-newline","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L275","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":53,"arglist-strs":["[s]"],"doc":"Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.","row":275},{"fixed-arities":[1],"end-row":299,"meta":{},"name-end-col":13,"name-end-row":288,"name-row":288,"added":"1.2","ns":"clojure.string","name":"blank?","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L288","filename":"/src/clj/clojure/string.clj","col":1,"name-col":7,"end-col":11,"arglist-strs":["[s]"],"doc":"True if s is nil, empty, or contains only whitespace.","row":288},{"fixed-arities":[2],"end-row":317,"meta":{},"name-end-col":21,"name-end-row":301,"name-row":301,"added":"1.2","ns":"clojure.string","name":"escape","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L301","filename":"/src/clj/clojure/string.clj","col":1,"name-col":15,"end-col":39,"arglist-strs":["[s cmap]"],"doc":"Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.","row":301},{"fixed-arities":[3,2],"end-row":338,"meta":{},"name-end-col":15,"name-end-row":319,"name-row":319,"added":"1.8","ns":"clojure.string","name":"index-of","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L319","filename":"/src/clj/clojure/string.clj","col":1,"name-col":7,"end-col":17,"arglist-strs":["[s value]","[s value from-index]"],"doc":"Return index of value (string or char) in s, optionally searching\n  forward from from-index. Return nil if value not found.","row":319},{"fixed-arities":[3,2],"end-row":359,"meta":{},"name-end-col":20,"name-end-row":340,"name-row":340,"added":"1.8","ns":"clojure.string","name":"last-index-of","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L340","filename":"/src/clj/clojure/string.clj","col":1,"name-col":7,"end-col":17,"arglist-strs":["[s value]","[s value from-index]"],"doc":"Return last index of value (string or char) in s, optionally\n  searching backward from from-index. Return nil if value not found.","row":340},{"fixed-arities":[2],"end-row":365,"meta":{},"name-end-col":19,"name-end-row":361,"name-row":361,"added":"1.8","ns":"clojure.string","name":"starts-with?","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L361","filename":"/src/clj/clojure/string.clj","col":1,"name-col":7,"end-col":38,"arglist-strs":["[s substr]"],"doc":"True if s starts with substr.","row":361},{"fixed-arities":[2],"end-row":371,"meta":{},"name-end-col":17,"name-end-row":367,"name-row":367,"added":"1.8","ns":"clojure.string","name":"ends-with?","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L367","filename":"/src/clj/clojure/string.clj","col":1,"name-col":7,"end-col":36,"arglist-strs":["[s substr]"],"doc":"True if s ends with substr.","row":367},{"fixed-arities":[2],"end-row":377,"meta":{},"name-end-col":16,"name-end-row":373,"name-row":373,"added":"1.8","ns":"clojure.string","name":"includes?","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/string.clj#L373","filename":"/src/clj/clojure/string.clj","col":1,"name-col":7,"end-col":36,"arglist-strs":["[s substr]"],"doc":"True if s includes substr.","row":373}]