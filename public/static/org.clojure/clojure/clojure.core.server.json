[{"end-row":23,"filename":"clojure/core/server.clj","name":"*session*","ns":"clojure.core.server","row":23},{"end-row":26,"filename":"clojure/core/server.clj","name":"lock","ns":"clojure.core.server","private":true,"row":26},{"end-row":27,"filename":"clojure/core/server.clj","name":"servers","ns":"clojure.core.server","private":true,"row":27},{"arglist-strs":["[lock-expr & body]"],"end-row":36,"filename":"clojure/core/server.clj","macro":true,"name":"with-lock","ns":"clojure.core.server","private":true,"row":29},{"arglist-strs":["[name daemon & body]"],"end-row":42,"filename":"clojure/core/server.clj","macro":true,"name":"thread","ns":"clojure.core.server","private":true,"row":38},{"fixed-arities":[2],"end-row":48,"private":true,"ns":"clojure.core.server","name":"required","filename":"clojure/core/server.clj","arglist-strs":["[opts prop]"],"doc":"Throw if opts does not contain prop.","row":44},{"fixed-arities":[1],"end-row":55,"private":true,"ns":"clojure.core.server","name":"validate-opts","filename":"clojure/core/server.clj","arglist-strs":["[{:keys [name port accept] :as opts}]"],"doc":"Validate server config options","row":50},{"fixed-arities":[8],"end-row":82,"private":true,"ns":"clojure.core.server","name":"accept-connection","filename":"clojure/core/server.clj","arglist-strs":["[conn name client-id in out err accept args]"],"doc":"Start accept function, to be invoked on a client thread, given:\n    conn - client socket\n    name - server name\n    client-id - client identifier\n    in - in stream\n    out - out stream\n    err - err stream\n    accept - accept fn symbol to invoke\n    args - to pass to accept-fn","row":57},{"arglist-strs":["[opts]"],"doc":"Start a socket server given the specified opts:\n    :address Host or address, string, defaults to loopback address\n    :port Port, integer, required\n    :name Name, required\n    :accept Namespaced symbol of the accept function to invoke, required\n    :args Vector of args to pass to accept function\n    :bind-err Bind *err* to socket out stream?, defaults to true\n    :server-daemon Is server thread a daemon?, defaults to true\n    :client-daemon Are client threads daemons?, defaults to true\n   Returns server socket.","end-row":123,"filename":"clojure/core/server.clj","fixed-arities":[1],"name":"start-server","ns":"clojure.core.server","row":84},{"arglist-strs":["[]","[name]"],"doc":"Stop server with name or use the server-name from *session* if none supplied.\n  Returns true if server stopped successfully, nil if not found, or throws if\n  there is an error closing the socket.","end-row":137,"filename":"clojure/core/server.clj","fixed-arities":[0,1],"name":"stop-server","ns":"clojure.core.server","row":125},{"arglist-strs":["[]"],"doc":"Stop all servers ignores all errors, and returns nil.","end-row":144,"filename":"clojure/core/server.clj","fixed-arities":[0],"name":"stop-servers","ns":"clojure.core.server","row":139},{"fixed-arities":[1],"end-row":155,"private":true,"ns":"clojure.core.server","name":"parse-props","filename":"clojure/core/server.clj","arglist-strs":["[props]"],"doc":"Parse clojure.server.* from properties to produce a map of server configs.","row":146},{"arglist-strs":["[system-props]"],"doc":"Start all servers specified in the system properties.","end-row":161,"filename":"clojure/core/server.clj","fixed-arities":[1],"name":"start-servers","ns":"clojure.core.server","row":157},{"arglist-strs":["[]"],"doc":"Initialize repl in user namespace and make standard repl requires.","end-row":167,"filename":"clojure/core/server.clj","fixed-arities":[0],"name":"repl-init","ns":"clojure.core.server","row":163},{"arglist-strs":["[request-prompt request-exit]"],"doc":"Enhanced :read hook for repl supporting :repl/quit.","end-row":178,"filename":"clojure/core/server.clj","fixed-arities":[2],"name":"repl-read","ns":"clojure.core.server","row":169},{"arglist-strs":["[]"],"doc":"REPL with predefined hooks for attachable socket server.","end-row":185,"filename":"clojure/core/server.clj","fixed-arities":[0],"name":"repl","ns":"clojure.core.server","row":180},{"arglist-strs":["[ex phase]"],"end-row":189,"filename":"clojure/core/server.clj","fixed-arities":[2],"name":"ex->data","ns":"clojure.core.server","private":true,"row":187},{"arglist-strs":["[in-reader out-fn & {:keys [stdin]}]"],"doc":"a REPL with structured output (for programs)\n  reads forms to eval from in-reader (a LineNumberingPushbackReader)\n  Closing the input or passing the form :repl/quit will cause it to return\n\n  Calls out-fn with data, one of:\n  {:tag :ret\n   :val val ;;eval result, or Throwable->map data if exception thrown\n   :ns ns-name-string\n   :ms long ;;eval time in milliseconds\n   :form string ;;iff successfully read\n   :exception true ;;iff exception thrown\n  }\n  {:tag :out\n   :val string} ;chars from during-eval *out*\n  {:tag :err\n   :val string} ;chars from during-eval *err*\n  {:tag :tap\n   :val val} ;values from tap>\n\n  You might get more than one :out or :err per eval, but exactly one :ret\n  tap output can happen at any time (i.e. between evals)\n  If during eval an attempt is made to read *in* it will read from in-reader unless :stdin is supplied\n\n  Alpha, subject to change.","end-row":261,"filename":"clojure/core/server.clj","name":"prepl","ns":"clojure.core.server","row":191},{"arglist-strs":["[valf]"],"end-row":270,"filename":"clojure/core/server.clj","fixed-arities":[1],"name":"resolve-fn","ns":"clojure.core.server","private":true,"row":263},{"arglist-strs":["[& {:keys [valf] :or {valf pr-str}}]"],"doc":"prepl bound to *in* and *out*, suitable for use with e.g. server/repl (socket-repl).\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default pr-str)\n\n  Alpha, subject to change.","end-row":293,"filename":"clojure/core/server.clj","name":"io-prepl","ns":"clojure.core.server","row":272},{"arglist-strs":["[host port in-reader out-fn & {:keys [valf readf] :or {valf read-string readf #(read %1 false %2)}}]"],"doc":"Implements a prepl on in-reader and out-fn by forwarding to a\n  remote [io-]prepl over a socket.  Messages will be read by readf, a\n  fn of a LineNumberingPushbackReader and EOF value or a symbol naming\n  same (default #(read %1 false %2)),\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default read-string). If that function\n  throws, :val will be unprocessed.\n\n  Alpha, subject to change.","end-row":338,"filename":"clojure/core/server.clj","name":"remote-prepl","ns":"clojure.core.server","row":295}]