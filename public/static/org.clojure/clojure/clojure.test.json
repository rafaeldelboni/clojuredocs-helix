[{"doc":"True by default.  If set to false, no test functions will\n   be created by deftest, set-test, or with-test.  Use this to omit\n   tests when compiling or loading production code.","end-row":250,"filename":"clojure/test.clj","name":"*load-tests*","ns":"clojure.test","row":245},{"doc":"The maximum depth of stack traces to print when an Exception\n  is thrown during a test.  Defaults to nil, which means print the \n  complete stack trace.","end-row":257,"filename":"clojure/test.clj","name":"*stack-trace-depth*","ns":"clojure.test","row":252},{"end-row":262,"filename":"clojure/test.clj","name":"*report-counters*","ns":"clojure.test","row":262},{"end-row":265,"filename":"clojure/test.clj","name":"*initial-report-counters*","ns":"clojure.test","row":264},{"end-row":267,"filename":"clojure/test.clj","name":"*testing-vars*","ns":"clojure.test","row":267},{"end-row":269,"filename":"clojure/test.clj","name":"*testing-contexts*","ns":"clojure.test","row":269},{"end-row":271,"filename":"clojure/test.clj","name":"*test-out*","ns":"clojure.test","row":271},{"arglist-strs":["[& body]"],"doc":"Runs body with *out* bound to the value of *test-out*.","end-row":278,"filename":"clojure/test.clj","macro":true,"name":"with-test-out","ns":"clojure.test","row":273},{"fixed-arities":[1],"end-row":292,"ns":"clojure.test","name":"file-position","filename":"clojure/test.clj","deprecated":"1.2","arglist-strs":["[n]"],"doc":"Returns a vector [filename line-number] for the nth call up the\n  stack.\n\n  Deprecated in 1.2: The information needed for test reporting is\n  now on :file and :line keys in the result map.","row":282},{"arglist-strs":["[m]"],"doc":"Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.","end-row":305,"filename":"clojure/test.clj","fixed-arities":[1],"name":"testing-vars-str","ns":"clojure.test","row":294},{"arglist-strs":["[]"],"doc":"Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.","end-row":312,"filename":"clojure/test.clj","fixed-arities":[0],"name":"testing-contexts-str","ns":"clojure.test","row":307},{"arglist-strs":["[name]"],"doc":"Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.","end-row":320,"filename":"clojure/test.clj","fixed-arities":[1],"name":"inc-report-counter","ns":"clojure.test","row":314},{"doc":"Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.  See the documentation at\n   the top of test_is.clj for more information on the types of\n   arguments for 'report'.","end-row":333,"filename":"clojure/test.clj","name":"report","ns":"clojure.test","row":324},{"fixed-arities":[2],"end-row":342,"private":true,"ns":"clojure.test","name":"file-and-line","filename":"clojure/test.clj","deprecated":"1.8","arglist-strs":["[exception depth]"],"row":335},{"arglist-strs":["[stacktrace]"],"end-row":349,"filename":"clojure/test.clj","fixed-arities":[1],"name":"stacktrace-file-and-line","ns":"clojure.test","private":true,"row":344},{"arglist-strs":["[m]"],"doc":"Add file and line information to a test result and call report.\n   If you are writing a custom assert-expr method, call this function\n   to pass test results to report.","end-row":367,"filename":"clojure/test.clj","fixed-arities":[1],"name":"do-report","ns":"clojure.test","row":351},{"arglist-strs":["[v]"],"doc":"Like var-get but returns nil if the var is unbound.","end-row":422,"filename":"clojure/test.clj","fixed-arities":[1],"name":"get-possibly-unbound-var","ns":"clojure.test","row":416},{"arglist-strs":["[x]"],"doc":"Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).","end-row":434,"filename":"clojure/test.clj","fixed-arities":[1],"name":"function?","ns":"clojure.test","row":424},{"arglist-strs":["[msg form]"],"doc":"Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).","end-row":453,"filename":"clojure/test.clj","fixed-arities":[2],"name":"assert-predicate","ns":"clojure.test","row":436},{"arglist-strs":["[msg form]"],"doc":"Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.","end-row":466,"filename":"clojure/test.clj","fixed-arities":[2],"name":"assert-any","ns":"clojure.test","row":455},{"end-row":481,"filename":"clojure/test.clj","name":"assert-expr","ns":"clojure.test","row":476},{"fixed-arities":[2],"end-row":546,"ns":"clojure.test","name":"try-expr","filename":"clojure/test.clj","macro":true,"arglist-strs":["[msg form]"],"doc":"Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.","row":538},{"fixed-arities":[1,2],"end-row":570,"ns":"clojure.test","name":"is","filename":"clojure/test.clj","macro":true,"arglist-strs":["[form]","[form msg]"],"doc":"Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.","row":554},{"arglist-strs":["[argv expr & args]"],"doc":"Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.","end-row":595,"filename":"clojure/test.clj","macro":true,"name":"are","ns":"clojure.test","row":572},{"arglist-strs":["[string & body]"],"doc":"Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).","end-row":603,"filename":"clojure/test.clj","macro":true,"name":"testing","ns":"clojure.test","row":597},{"arglist-strs":["[definition & body]"],"doc":"Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.","end-row":619,"filename":"clojure/test.clj","macro":true,"name":"with-test","ns":"clojure.test","row":609},{"arglist-strs":["[name & body]"],"doc":"Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.","end-row":637,"filename":"clojure/test.clj","macro":true,"name":"deftest","ns":"clojure.test","row":622},{"arglist-strs":["[name & body]"],"doc":"Like deftest but creates a private var.","end-row":645,"filename":"clojure/test.clj","macro":true,"name":"deftest-","ns":"clojure.test","row":639},{"arglist-strs":["[name & body]"],"doc":"Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.","end-row":657,"filename":"clojure/test.clj","macro":true,"name":"set-test","ns":"clojure.test","row":648},{"fixed-arities":[2],"end-row":668,"private":true,"ns":"clojure.test","name":"add-ns-meta","filename":"clojure/test.clj","arglist-strs":["[key coll]"],"doc":"Adds elements in coll to the current namespace metadata as the\n  value of key.","row":663},{"doc":"Wrap test runs in a fixture function to perform setup and\n  teardown. Using a fixture-type of :each wraps every test\n  individually, while :once wraps the whole run in a single function.","end-row":675,"filename":"clojure/test.clj","name":"use-fixtures","ns":"clojure.test","row":670},{"fixed-arities":[1],"end-row":687,"private":true,"ns":"clojure.test","name":"default-fixture","filename":"clojure/test.clj","arglist-strs":["[f]"],"doc":"The default, empty, fixture function.  Just calls its argument.","row":683},{"arglist-strs":["[f1 f2]"],"doc":"Composes two fixture functions, creating a new fixture function\n  that combines their behavior.","end-row":694,"filename":"clojure/test.clj","fixed-arities":[2],"name":"compose-fixtures","ns":"clojure.test","row":689},{"arglist-strs":["[fixtures]"],"doc":"Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.","end-row":701,"filename":"clojure/test.clj","fixed-arities":[1],"name":"join-fixtures","ns":"clojure.test","row":696},{"arglist-strs":["[v]"],"doc":"If v has a function in its :test metadata, calls that function,\n  with *testing-vars* bound to (conj *testing-vars* v).","end-row":721,"filename":"clojure/test.clj","fixed-arities":[1],"name":"test-var","ns":"clojure.test","row":708},{"arglist-strs":["[vars]"],"doc":"Groups vars by their namespace and runs test-var on them with\n  appropriate fixtures applied.","end-row":735,"filename":"clojure/test.clj","fixed-arities":[1],"name":"test-vars","ns":"clojure.test","row":723},{"arglist-strs":["[ns]"],"doc":"Calls test-vars on every var interned in the namespace, with fixtures.","end-row":741,"filename":"clojure/test.clj","fixed-arities":[1],"name":"test-all-vars","ns":"clojure.test","row":737},{"arglist-strs":["[ns]"],"doc":"If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  Returns the final, dereferenced state of\n  *report-counters*.","end-row":762,"filename":"clojure/test.clj","fixed-arities":[1],"name":"test-ns","ns":"clojure.test","row":743},{"arglist-strs":["[]","[& namespaces]"],"doc":"Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given.  Returns a map\n  summarizing test results.","end-row":778,"filename":"clojure/test.clj","fixed-arities":[0],"name":"run-tests","ns":"clojure.test","row":768},{"arglist-strs":["[]","[re]"],"doc":"Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.","end-row":787,"filename":"clojure/test.clj","fixed-arities":[0,1],"name":"run-all-tests","ns":"clojure.test","row":780},{"arglist-strs":["[summary]"],"doc":"Returns true if the given test summary indicates all tests\n  were successful, false otherwise.","end-row":795,"filename":"clojure/test.clj","fixed-arities":[1],"name":"successful?","ns":"clojure.test","row":789},{"arglist-strs":["[v]"],"doc":"Runs the tests for a single Var, with fixtures executed around the test, and summary output after.","end-row":811,"filename":"clojure/test.clj","fixed-arities":[1],"name":"run-test-var","ns":"clojure.test","row":797},{"fixed-arities":[1],"end-row":830,"ns":"clojure.test","name":"run-test","filename":"clojure/test.clj","macro":true,"arglist-strs":["[test-symbol]"],"doc":"Runs a single test.\n\n  Because the intent is to run a single test, there is no check for the namespace test-ns-hook.","row":813}]