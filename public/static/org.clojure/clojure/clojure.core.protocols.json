[{"end-row":185,"meta":{},"name-end-col":24,"index":0,"name-end-row":182,"name-row":182,"ns":"clojure.core.protocols","name":"Datafiable","defined-by":"clojure.core/defprotocol","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L182","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":14,"end-col":74,"row":182},{"fixed-arities":[3,2],"end-row":53,"meta":{},"name-end-col":19,"index":0,"name-end-row":33,"private":true,"name-row":33,"ns":"clojure.core.protocols","name":"iter-reduce","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L33","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":8,"end-col":18,"arglist-strs":["[coll f]","[coll f val]"],"row":33},{"end-row":198,"meta":{},"name-end-col":23,"index":0,"name-end-row":194,"name-row":194,"ns":"clojure.core.protocols","name":"Navigable","defined-by":"clojure.core/defprotocol","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L194","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":14,"end-col":28,"row":194},{"fixed-arities":[1],"end-row":185,"meta":{},"name-end-col":10,"protocol-ns":"clojure.core.protocols","index":0,"name-end-row":185,"name-row":185,"ns":"clojure.core.protocols","name":"datafy","defined-by":"clojure.core/defprotocol","protocol-name":"Datafiable","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L185","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":3,"name-col":4,"end-col":73,"arglist-strs":["[o]"],"doc":"return a representation of o as data (default identity)","row":185},{"fixed-arities":[3],"end-row":180,"meta":{},"name-end-col":13,"protocol-ns":"clojure.core.protocols","index":0,"name-end-row":180,"name-row":180,"ns":"clojure.core.protocols","name":"kv-reduce","defined-by":"clojure.core/defprotocol","protocol-name":"IKVReduce","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L180","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":3,"name-col":4,"end-col":28,"arglist-strs":["[amap f init]"],"row":180},{"fixed-arities":[3],"end-row":66,"meta":{},"name-end-col":24,"index":0,"name-end-row":55,"private":true,"name-row":55,"ns":"clojure.core.protocols","name":"naive-seq-reduce","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L55","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":8,"end-col":13,"arglist-strs":["[s f val]"],"doc":"Reduces a seq, ignoring any opportunities to switch to a more\n  specialized implementation.","row":55},{"fixed-arities":[3],"end-row":73,"meta":{},"name-end-col":33,"index":0,"name-end-row":68,"private":true,"name-row":68,"ns":"clojure.core.protocols","name":"interface-or-naive-reduce","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L68","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":8,"end-col":36,"arglist-strs":["[coll f val]"],"doc":"Reduces via IReduceInit if possible, else naively.","row":68},{"end-row":180,"meta":{},"name-end-col":23,"index":0,"name-end-row":175,"name-row":175,"ns":"clojure.core.protocols","name":"IKVReduce","defined-by":"clojure.core/defprotocol","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L175","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":14,"end-col":29,"doc":"Protocol for concrete associative types that can reduce themselves\n   via a function of key and val faster than first/next recursion over map\n   entries. Called by clojure.core/reduce-kv, and has same\n   semantics (just different arg order).","row":175},{"fixed-arities":[3,2],"end-row":17,"meta":{},"name-end-col":15,"protocol-ns":"clojure.core.protocols","index":0,"name-end-row":17,"name-row":17,"ns":"clojure.core.protocols","name":"coll-reduce","defined-by":"clojure.core/defprotocol","protocol-name":"CollReduce","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L17","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":3,"name-col":4,"end-col":38,"arglist-strs":["[coll f]","[coll f val]"],"row":17},{"end-row":22,"meta":{},"name-end-col":28,"index":0,"name-end-row":19,"name-row":19,"ns":"clojure.core.protocols","name":"InternalReduce","defined-by":"clojure.core/defprotocol","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L19","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":14,"end-col":35,"doc":"Protocol for concrete seq types that can reduce themselves\n   faster than first/next recursion. Called by clojure.core/reduce.","row":19},{"fixed-arities":[3],"end-row":198,"meta":{},"name-end-col":7,"protocol-ns":"clojure.core.protocols","index":0,"name-end-row":197,"name-row":197,"ns":"clojure.core.protocols","name":"nav","defined-by":"clojure.core/defprotocol","protocol-name":"Navigable","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L197","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":3,"name-col":4,"end-col":27,"arglist-strs":["[coll k v]"],"doc":"return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.","row":197},{"fixed-arities":[3],"end-row":22,"meta":{},"name-end-col":19,"protocol-ns":"clojure.core.protocols","index":0,"name-end-row":22,"name-row":22,"ns":"clojure.core.protocols","name":"internal-reduce","defined-by":"clojure.core/defprotocol","protocol-name":"InternalReduce","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L22","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":3,"name-col":4,"end-col":34,"arglist-strs":["[seq f start]"],"row":22},{"end-row":17,"meta":{},"name-end-col":24,"index":0,"name-end-row":13,"name-row":13,"ns":"clojure.core.protocols","name":"CollReduce","defined-by":"clojure.core/defprotocol","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L13","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":14,"end-col":39,"doc":"Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable.","row":13},{"fixed-arities":[3,2],"end-row":31,"meta":{},"name-end-col":18,"index":0,"name-end-row":24,"private":true,"name-row":24,"ns":"clojure.core.protocols","name":"seq-reduce","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/core/protocols.clj#L24","lang":[],"filename":"/src/clj/clojure/core/protocols.clj","col":1,"name-col":8,"end-col":36,"arglist-strs":["[coll f]","[coll f val]"],"row":24}]