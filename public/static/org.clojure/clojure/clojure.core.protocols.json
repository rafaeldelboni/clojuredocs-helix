[{"end-row":17,"meta":null,"name-end-col":24,"name-end-row":13,"name-row":13,"ns":"clojure.core.protocols","name":"CollReduce","defined-by":"clojure.core/defprotocol","filename":"clojure/core/protocols.clj","col":1,"name-col":14,"end-col":39,"doc":"Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable.","row":13},{"fixed-arities":[3,2],"end-row":17,"meta":null,"name-end-col":15,"protocol-ns":"clojure.core.protocols","name-end-row":17,"name-row":17,"ns":"clojure.core.protocols","name":"coll-reduce","defined-by":"clojure.core/defprotocol","protocol-name":"CollReduce","filename":"clojure/core/protocols.clj","col":3,"name-col":4,"end-col":38,"arglist-strs":["[coll f]","[coll f val]"],"row":17},{"end-row":22,"meta":null,"name-end-col":28,"name-end-row":19,"name-row":19,"ns":"clojure.core.protocols","name":"InternalReduce","defined-by":"clojure.core/defprotocol","filename":"clojure/core/protocols.clj","col":1,"name-col":14,"end-col":35,"doc":"Protocol for concrete seq types that can reduce themselves\n   faster than first/next recursion. Called by clojure.core/reduce.","row":19},{"fixed-arities":[3],"end-row":22,"meta":null,"name-end-col":19,"protocol-ns":"clojure.core.protocols","name-end-row":22,"name-row":22,"ns":"clojure.core.protocols","name":"internal-reduce","defined-by":"clojure.core/defprotocol","protocol-name":"InternalReduce","filename":"clojure/core/protocols.clj","col":3,"name-col":4,"end-col":34,"arglist-strs":["[seq f start]"],"row":22},{"fixed-arities":[3,2],"end-row":31,"meta":null,"name-end-col":18,"name-end-row":24,"private":true,"name-row":24,"ns":"clojure.core.protocols","name":"seq-reduce","defined-by":"clojure.core/defn-","filename":"clojure/core/protocols.clj","col":1,"name-col":8,"end-col":36,"arglist-strs":["[coll f]","[coll f val]"],"row":24},{"fixed-arities":[3,2],"end-row":53,"meta":null,"name-end-col":19,"name-end-row":33,"private":true,"name-row":33,"ns":"clojure.core.protocols","name":"iter-reduce","defined-by":"clojure.core/defn-","filename":"clojure/core/protocols.clj","col":1,"name-col":8,"end-col":18,"arglist-strs":["[coll f]","[coll f val]"],"row":33},{"fixed-arities":[3],"end-row":66,"meta":null,"name-end-col":24,"name-end-row":55,"private":true,"name-row":55,"ns":"clojure.core.protocols","name":"naive-seq-reduce","defined-by":"clojure.core/defn-","filename":"clojure/core/protocols.clj","col":1,"name-col":8,"end-col":13,"arglist-strs":["[s f val]"],"doc":"Reduces a seq, ignoring any opportunities to switch to a more\n  specialized implementation.","row":55},{"fixed-arities":[3],"end-row":73,"meta":null,"name-end-col":33,"name-end-row":68,"private":true,"name-row":68,"ns":"clojure.core.protocols","name":"interface-or-naive-reduce","defined-by":"clojure.core/defn-","filename":"clojure/core/protocols.clj","col":1,"name-col":8,"end-col":36,"arglist-strs":["[coll f val]"],"doc":"Reduces via IReduceInit if possible, else naively.","row":68},{"end-row":180,"meta":null,"name-end-col":23,"name-end-row":175,"name-row":175,"ns":"clojure.core.protocols","name":"IKVReduce","defined-by":"clojure.core/defprotocol","filename":"clojure/core/protocols.clj","col":1,"name-col":14,"end-col":29,"doc":"Protocol for concrete associative types that can reduce themselves\n   via a function of key and val faster than first/next recursion over map\n   entries. Called by clojure.core/reduce-kv, and has same\n   semantics (just different arg order).","row":175},{"fixed-arities":[3],"end-row":180,"meta":null,"name-end-col":13,"protocol-ns":"clojure.core.protocols","name-end-row":180,"name-row":180,"ns":"clojure.core.protocols","name":"kv-reduce","defined-by":"clojure.core/defprotocol","protocol-name":"IKVReduce","filename":"clojure/core/protocols.clj","col":3,"name-col":4,"end-col":28,"arglist-strs":["[amap f init]"],"row":180},{"end-row":185,"meta":null,"name-end-col":24,"name-end-row":182,"name-row":182,"ns":"clojure.core.protocols","name":"Datafiable","defined-by":"clojure.core/defprotocol","filename":"clojure/core/protocols.clj","col":1,"name-col":14,"end-col":74,"row":182},{"fixed-arities":[1],"end-row":185,"meta":null,"name-end-col":10,"protocol-ns":"clojure.core.protocols","name-end-row":185,"name-row":185,"ns":"clojure.core.protocols","name":"datafy","defined-by":"clojure.core/defprotocol","protocol-name":"Datafiable","filename":"clojure/core/protocols.clj","col":3,"name-col":4,"end-col":73,"arglist-strs":["[o]"],"doc":"return a representation of o as data (default identity)","row":185},{"end-row":198,"meta":null,"name-end-col":23,"name-end-row":194,"name-row":194,"ns":"clojure.core.protocols","name":"Navigable","defined-by":"clojure.core/defprotocol","filename":"clojure/core/protocols.clj","col":1,"name-col":14,"end-col":28,"row":194},{"fixed-arities":[3],"end-row":198,"meta":null,"name-end-col":7,"protocol-ns":"clojure.core.protocols","name-end-row":197,"name-row":197,"ns":"clojure.core.protocols","name":"nav","defined-by":"clojure.core/defprotocol","protocol-name":"Navigable","filename":"clojure/core/protocols.clj","col":3,"name-col":4,"end-col":27,"arglist-strs":["[coll k v]"],"doc":"return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.","row":197}]