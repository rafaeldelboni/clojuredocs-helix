[{"doc":"Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable.","end-row":17,"filename":"clojure/core/protocols.clj","name":"CollReduce","ns":"clojure.core.protocols","row":13},{"arglist-strs":["[coll f]","[coll f val]"],"end-row":17,"filename":"clojure/core/protocols.clj","fixed-arities":[3,2],"name":"coll-reduce","ns":"clojure.core.protocols","row":17},{"doc":"Protocol for concrete seq types that can reduce themselves\n   faster than first/next recursion. Called by clojure.core/reduce.","end-row":22,"filename":"clojure/core/protocols.clj","name":"InternalReduce","ns":"clojure.core.protocols","row":19},{"arglist-strs":["[seq f start]"],"end-row":22,"filename":"clojure/core/protocols.clj","fixed-arities":[3],"name":"internal-reduce","ns":"clojure.core.protocols","row":22},{"arglist-strs":["[coll f]","[coll f val]"],"end-row":31,"filename":"clojure/core/protocols.clj","fixed-arities":[3,2],"name":"seq-reduce","ns":"clojure.core.protocols","private":true,"row":24},{"arglist-strs":["[coll f]","[coll f val]"],"end-row":53,"filename":"clojure/core/protocols.clj","fixed-arities":[3,2],"name":"iter-reduce","ns":"clojure.core.protocols","private":true,"row":33},{"fixed-arities":[3],"end-row":66,"private":true,"ns":"clojure.core.protocols","name":"naive-seq-reduce","filename":"clojure/core/protocols.clj","arglist-strs":["[s f val]"],"doc":"Reduces a seq, ignoring any opportunities to switch to a more\n  specialized implementation.","row":55},{"fixed-arities":[3],"end-row":73,"private":true,"ns":"clojure.core.protocols","name":"interface-or-naive-reduce","filename":"clojure/core/protocols.clj","arglist-strs":["[coll f val]"],"doc":"Reduces via IReduceInit if possible, else naively.","row":68},{"doc":"Protocol for concrete associative types that can reduce themselves\n   via a function of key and val faster than first/next recursion over map\n   entries. Called by clojure.core/reduce-kv, and has same\n   semantics (just different arg order).","end-row":180,"filename":"clojure/core/protocols.clj","name":"IKVReduce","ns":"clojure.core.protocols","row":175},{"arglist-strs":["[amap f init]"],"end-row":180,"filename":"clojure/core/protocols.clj","fixed-arities":[3],"name":"kv-reduce","ns":"clojure.core.protocols","row":180},{"end-row":185,"filename":"clojure/core/protocols.clj","name":"Datafiable","ns":"clojure.core.protocols","row":182},{"arglist-strs":["[o]"],"doc":"return a representation of o as data (default identity)","end-row":185,"filename":"clojure/core/protocols.clj","fixed-arities":[1],"name":"datafy","ns":"clojure.core.protocols","row":185},{"end-row":198,"filename":"clojure/core/protocols.clj","name":"Navigable","ns":"clojure.core.protocols","row":194},{"arglist-strs":["[coll k v]"],"doc":"return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.","end-row":198,"filename":"clojure/core/protocols.clj","fixed-arities":[3],"name":"nav","ns":"clojure.core.protocols","row":197}]