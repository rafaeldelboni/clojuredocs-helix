[{"end-row":73,"filename":"clojure/repl.clj","name":"special-doc-map","ns":"clojure.repl","private":true,"row":19},{"arglist-strs":["[name-symbol]"],"end-row":78,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"special-doc","ns":"clojure.repl","private":true,"row":75},{"arglist-strs":["[nspace]"],"end-row":81,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"namespace-doc","ns":"clojure.repl","private":true,"row":80},{"arglist-strs":["[{n :ns nm :name :keys [forms arglists special-form doc url macro spec] :as m}]"],"end-row":113,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"print-doc","ns":"clojure.repl","private":true,"row":83},{"arglist-strs":["[re-string-or-pattern]"],"doc":"Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern","end-row":129,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"find-doc","ns":"clojure.repl","row":115},{"fixed-arities":[1],"end-row":142,"ns":"clojure.repl","name":"doc","filename":"clojure/repl.clj","macro":true,"arglist-strs":["[name]"],"doc":"Prints documentation for a var or special form given its name,\n   or for a spec if given a keyword","row":131},{"arglist-strs":["[x]"],"doc":"Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)","end-row":170,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"source-fn","ns":"clojure.repl","row":147},{"fixed-arities":[1],"end-row":179,"ns":"clojure.repl","name":"source","filename":"clojure/repl.clj","macro":true,"arglist-strs":["[n]"],"doc":"Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .clj is in the classpath.\n\n  Example: (source filter)","row":172},{"arglist-strs":["[str-or-pattern]"],"doc":"Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.","end-row":193,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"apropos","ns":"clojure.repl","row":181},{"arglist-strs":["[ns]"],"doc":"Returns a sorted seq of symbols naming public vars in\n  a namespace or namespace alias. Looks for aliases in *ns*","end-row":199,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"dir-fn","ns":"clojure.repl","row":195},{"fixed-arities":[1],"end-row":205,"ns":"clojure.repl","name":"dir","filename":"clojure/repl.clj","macro":true,"arglist-strs":["[nsname]"],"doc":"Prints a sorted directory of public vars in a namespace","row":201},{"arglist-strs":["[fn-name]"],"doc":"Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.","end-row":212,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"demunge","ns":"clojure.repl","row":207},{"arglist-strs":["[t]"],"doc":"Returns the initial cause of an exception or error by peeling off all of\n  its wrappers","end-row":225,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"root-cause","ns":"clojure.repl","row":214},{"arglist-strs":["[el]"],"doc":"Returns a (possibly unmunged) string representation of a StackTraceElement","end-row":238,"filename":"clojure/repl.clj","fixed-arities":[1],"name":"stack-element-str","ns":"clojure.repl","row":227},{"arglist-strs":["[]","[e-or-depth]","[e depth]"],"doc":"Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the\n  most recent repl exception (*e), and a depth of 12.","end-row":268,"filename":"clojure/repl.clj","fixed-arities":[0,1,2],"name":"pst","ns":"clojure.repl","row":240},{"arglist-strs":["[]","[thread]"],"doc":"Returns a function that takes one arg and uses that as an exception message\n  to stop the given thread.  Defaults to the current thread","end-row":277,"filename":"clojure/repl.clj","fixed-arities":[0,1],"name":"thread-stopper","ns":"clojure.repl","row":273},{"arglist-strs":["[]","[f]"],"doc":"Register INT signal handler.  After calling this, Ctrl-C will cause\n  the given function f to be called with a single argument, the signal.\n  Uses thread-stopper if no function given.","end-row":289,"filename":"clojure/repl.clj","fixed-arities":[0,1],"name":"set-break-handler!","ns":"clojure.repl","row":279}]