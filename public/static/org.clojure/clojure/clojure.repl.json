[{"end-row":73,"meta":{"private":true},"name-end-col":31,"name-end-row":19,"private":true,"name-row":19,"ns":"clojure.repl","name":"special-doc-map","defined-by":"clojure.core/def","filename":"clojure/repl.clj","col":1,"name-col":16,"end-col":81,"row":19},{"fixed-arities":[1],"end-row":78,"meta":null,"name-end-col":19,"name-end-row":75,"private":true,"name-row":75,"ns":"clojure.repl","name":"special-doc","defined-by":"clojure.core/defn-","filename":"clojure/repl.clj","col":1,"name-col":8,"end-col":30,"arglist-strs":["[name-symbol]"],"row":75},{"fixed-arities":[1],"end-row":81,"meta":null,"name-end-col":21,"name-end-row":80,"private":true,"name-row":80,"ns":"clojure.repl","name":"namespace-doc","defined-by":"clojure.core/defn-","filename":"clojure/repl.clj","col":1,"name-col":8,"end-col":48,"arglist-strs":["[nspace]"],"row":80},{"fixed-arities":[1],"end-row":113,"meta":null,"name-end-col":17,"name-end-row":83,"private":true,"name-row":83,"ns":"clojure.repl","name":"print-doc","defined-by":"clojure.core/defn-","filename":"clojure/repl.clj","col":1,"name-col":8,"end-col":72,"arglist-strs":["[{n :ns nm :name :keys [forms arglists special-form doc url macro spec] :as m}]"],"row":83},{"fixed-arities":[1],"end-row":129,"meta":{"added":"1.0"},"name-end-col":15,"name-end-row":115,"name-row":115,"added":"1.0","ns":"clojure.repl","name":"find-doc","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":32,"arglist-strs":["[re-string-or-pattern]"],"doc":"Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern","row":115},{"fixed-arities":[1],"end-row":142,"meta":{"added":"1.0"},"name-end-col":14,"name-end-row":131,"name-row":131,"added":"1.0","ns":"clojure.repl","name":"doc","defined-by":"clojure.core/defmacro","filename":"clojure/repl.clj","macro":true,"col":1,"name-col":11,"end-col":58,"arglist-strs":["[name]"],"doc":"Prints documentation for a var or special form given its name,\n   or for a spec if given a keyword","row":131},{"fixed-arities":[1],"end-row":170,"meta":null,"name-end-col":16,"name-end-row":147,"name-row":147,"ns":"clojure.repl","name":"source-fn","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":29,"arglist-strs":["[x]"],"doc":"Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)","row":147},{"fixed-arities":[1],"end-row":179,"meta":null,"name-end-col":17,"name-end-row":172,"name-row":172,"ns":"clojure.repl","name":"source","defined-by":"clojure.core/defmacro","filename":"clojure/repl.clj","macro":true,"col":1,"name-col":11,"end-col":60,"arglist-strs":["[n]"],"doc":"Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .clj is in the classpath.\n\n  Example: (source filter)","row":172},{"fixed-arities":[1],"end-row":193,"meta":null,"name-end-col":14,"name-end-row":181,"name-row":181,"ns":"clojure.repl","name":"apropos","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":31,"arglist-strs":["[str-or-pattern]"],"doc":"Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.","row":181},{"fixed-arities":[1],"end-row":199,"meta":null,"name-end-col":13,"name-end-row":195,"name-row":195,"ns":"clojure.repl","name":"dir-fn","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":74,"arglist-strs":["[ns]"],"doc":"Returns a sorted seq of symbols naming public vars in\n  a namespace or namespace alias. Looks for aliases in *ns*","row":195},{"fixed-arities":[1],"end-row":205,"meta":null,"name-end-col":14,"name-end-row":201,"name-row":201,"ns":"clojure.repl","name":"dir","defined-by":"clojure.core/defmacro","filename":"clojure/repl.clj","macro":true,"col":1,"name-col":11,"end-col":20,"arglist-strs":["[nsname]"],"doc":"Prints a sorted directory of public vars in a namespace","row":201},{"fixed-arities":[1],"end-row":212,"meta":{"added":"1.3"},"name-end-col":14,"name-end-row":207,"name-row":207,"added":"1.3","ns":"clojure.repl","name":"demunge","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":43,"arglist-strs":["[fn-name]"],"doc":"Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.","row":207},{"fixed-arities":[1],"end-row":225,"meta":{"added":"1.3"},"name-end-col":17,"name-end-row":214,"name-row":214,"added":"1.3","ns":"clojure.repl","name":"root-cause","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":18,"arglist-strs":["[t]"],"doc":"Returns the initial cause of an exception or error by peeling off all of\n  its wrappers","row":214},{"fixed-arities":[1],"end-row":238,"meta":{"added":"1.3"},"name-end-col":24,"name-end-row":227,"name-row":227,"added":"1.3","ns":"clojure.repl","name":"stack-element-str","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":63,"arglist-strs":["[el]"],"doc":"Returns a (possibly unmunged) string representation of a StackTraceElement","row":227},{"fixed-arities":[0,1,2],"end-row":268,"meta":{"added":"1.3"},"name-end-col":10,"name-end-row":240,"name-row":240,"added":"1.3","ns":"clojure.repl","name":"pst","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":55,"arglist-strs":["[]","[e-or-depth]","[e depth]"],"doc":"Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the\n  most recent repl exception (*e), and a depth of 12.","row":240},{"fixed-arities":[0,1],"end-row":277,"meta":null,"name-end-col":21,"name-end-row":273,"name-row":273,"ns":"clojure.repl","name":"thread-stopper","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":53,"arglist-strs":["[]","[thread]"],"doc":"Returns a function that takes one arg and uses that as an exception message\n  to stop the given thread.  Defaults to the current thread","row":273},{"fixed-arities":[0,1],"end-row":289,"meta":null,"name-end-col":25,"name-end-row":279,"name-row":279,"ns":"clojure.repl","name":"set-break-handler!","defined-by":"clojure.core/defn","filename":"clojure/repl.clj","col":1,"name-col":7,"end-col":51,"arglist-strs":["[]","[f]"],"doc":"Register INT signal handler.  After calling this, Ctrl-C will cause\n  the given function f to be called with a single argument, the signal.\n  Uses thread-stopper if no function given.","row":279}]