[{"end-row":17,"filename":"clojure/data.clj","name":"diff","ns":"clojure.data","row":17},{"fixed-arities":[2],"end-row":22,"private":true,"ns":"clojure.data","name":"atom-diff","filename":"clojure/data.clj","arglist-strs":["[a b]"],"doc":"Internal helper for diff.","row":19},{"fixed-arities":[1],"end-row":33,"private":true,"ns":"clojure.data","name":"vectorize","filename":"clojure/data.clj","arglist-strs":["[m]"],"doc":"Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys","row":25},{"fixed-arities":[3],"end-row":49,"private":true,"ns":"clojure.data","name":"diff-associative-key","filename":"clojure/data.clj","arglist-strs":["[a b k]"],"doc":"Diff associative things a and b, comparing only the key k.","row":35},{"fixed-arities":[3],"end-row":60,"private":true,"ns":"clojure.data","name":"diff-associative","filename":"clojure/data.clj","arglist-strs":["[a b ks]"],"doc":"Diff associative things a and b, comparing only keys in ks.","row":51},{"arglist-strs":["[a b]"],"end-row":67,"filename":"clojure/data.clj","fixed-arities":[2],"name":"diff-sequential","ns":"clojure.data","private":true,"row":62},{"doc":"Implementation detail. Subject to change.","end-row":71,"filename":"clojure/data.clj","name":"EqualityPartition","ns":"clojure.data","row":69},{"arglist-strs":["[x]"],"doc":"Implementation detail. Subject to change.","end-row":71,"filename":"clojure/data.clj","fixed-arities":[1],"name":"equality-partition","ns":"clojure.data","row":71},{"doc":"Implementation detail. Subject to change.","end-row":75,"filename":"clojure/data.clj","name":"Diff","ns":"clojure.data","row":73},{"arglist-strs":["[a b]"],"doc":"Implementation detail. Subject to change.","end-row":75,"filename":"clojure/data.clj","fixed-arities":[2],"name":"diff-similar","ns":"clojure.data","row":75},{"arglist-strs":["[s]"],"end-row":104,"filename":"clojure/data.clj","fixed-arities":[1],"name":"as-set-value","ns":"clojure.data","private":true,"row":102},{"arglist-strs":["[a b]"],"doc":"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.","end-row":142,"filename":"clojure/data.clj","fixed-arities":[2],"name":"diff","ns":"clojure.data","row":124}]