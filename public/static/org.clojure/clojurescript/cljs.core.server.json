[{"arglist-strs":["[& body]"],"end-row":25,"filename":"cljs/core/server.clj","macro":true,"name":"with-bindings","ns":"cljs.core.server","row":21},{"arglist-strs":["[valf]"],"end-row":34,"filename":"cljs/core/server.clj","fixed-arities":[1],"name":"resolve-fn","ns":"cljs.core.server","private":true,"row":27},{"arglist-strs":["[v]"],"end-row":37,"filename":"cljs/core/server.clj","fixed-arities":[1],"name":"repl-quit?","ns":"cljs.core.server","row":36},{"arglist-strs":["[repl-env {:keys [special-fns] :as opts} in-reader out-fn & {:keys [stdin]}]"],"doc":"A REPL with structured output (for programs)\n  reads forms to eval from in-reader (a LineNumberingPushbackReader)\n  Closing the input or passing the form :cljs/quit or :repl/quit will cause it\n  to return\n\n  Calls out-fn with data, one of:\n  {:tag :ret\n   :val string ;;eval result\n   :ns ns-name-string\n   :ms long ;;eval time in milliseconds\n   :form string ;;iff successfully read\n  }\n  {:tag :out\n   :val string} ;chars from during-eval *out*\n  {:tag :err\n   :val string} ;chars from during-eval *err*\n  {:tag :tap\n   :val string} ;values from tap>\n\n  You might get more than one :out or :err per eval, but exactly one :ret\n  tap output can happen at any time (i.e. between evals)\n  If during eval an attempt is made to read *in* it will read from in-reader unless :stdin is supplied\n","end-row":130,"filename":"cljs/core/server.clj","name":"prepl","ns":"cljs.core.server","row":39},{"arglist-strs":["[& {:keys [valf repl-env opts] :or {valf #(if (string? %) % (pr-str %))}}]"],"doc":"prepl bound to *in* and *out*, suitable for use with e.g. server/repl (socket-repl).\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default identity)","end-row":146,"filename":"cljs/core/server.clj","name":"io-prepl","ns":"cljs.core.server","row":132},{"arglist-strs":["[form]"],"end-row":153,"filename":"cljs/core/server.clj","fixed-arities":[1],"macro":true,"name":"clj-eval","ns":"cljs.core.server","row":152}]