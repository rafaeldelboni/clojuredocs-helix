[{"end-row":25,"meta":{},"name-end-col":24,"name-end-row":21,"name-row":21,"ns":"cljs.core.server","name":"with-bindings","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojurescript/blob/r1.11.60/src/main/clojure/cljs/core/server.clj#L21","filename":"/src/main/clojure/cljs/core/server.clj","macro":true,"col":1,"name-col":11,"end-col":14,"arglist-strs":["[& body]"],"varargs-min-arity":0,"row":21},{"fixed-arities":[1],"end-row":34,"meta":{},"name-end-col":18,"name-end-row":27,"private":true,"name-row":27,"ns":"cljs.core.server","name":"resolve-fn","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojurescript/blob/r1.11.60/src/main/clojure/cljs/core/server.clj#L27","filename":"/src/main/clojure/cljs/core/server.clj","col":1,"name-col":8,"end-col":11,"arglist-strs":["[valf]"],"row":27},{"fixed-arities":[1],"end-row":37,"meta":{},"name-end-col":17,"name-end-row":36,"name-row":36,"ns":"cljs.core.server","name":"repl-quit?","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojurescript/blob/r1.11.60/src/main/clojure/cljs/core/server.clj#L36","filename":"/src/main/clojure/cljs/core/server.clj","col":1,"name-col":7,"end-col":36,"arglist-strs":["[v]"],"row":36},{"end-row":130,"meta":{},"name-end-col":12,"name-end-row":39,"name-row":39,"ns":"cljs.core.server","name":"prepl","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojurescript/blob/r1.11.60/src/main/clojure/cljs/core/server.clj#L39","filename":"/src/main/clojure/cljs/core/server.clj","col":1,"name-col":7,"end-col":59,"arglist-strs":["[repl-env {:keys [special-fns] :as opts} in-reader out-fn & {:keys [stdin]}]"],"varargs-min-arity":4,"doc":"A REPL with structured output (for programs)\n  reads forms to eval from in-reader (a LineNumberingPushbackReader)\n  Closing the input or passing the form :cljs/quit or :repl/quit will cause it\n  to return\n\n  Calls out-fn with data, one of:\n  {:tag :ret\n   :val string ;;eval result\n   :ns ns-name-string\n   :ms long ;;eval time in milliseconds\n   :form string ;;iff successfully read\n  }\n  {:tag :out\n   :val string} ;chars from during-eval *out*\n  {:tag :err\n   :val string} ;chars from during-eval *err*\n  {:tag :tap\n   :val string} ;values from tap>\n\n  You might get more than one :out or :err per eval, but exactly one :ret\n  tap output can happen at any time (i.e. between evals)\n  If during eval an attempt is made to read *in* it will read from in-reader unless :stdin is supplied\n","row":39},{"end-row":146,"meta":{},"name-end-col":15,"name-end-row":132,"name-row":132,"ns":"cljs.core.server","name":"io-prepl","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojurescript/blob/r1.11.60/src/main/clojure/cljs/core/server.clj#L132","filename":"/src/main/clojure/cljs/core/server.clj","col":1,"name-col":7,"end-col":55,"arglist-strs":["[& {:keys [valf repl-env opts] :or {valf #(if (string? %) % (pr-str %))}}]"],"varargs-min-arity":0,"doc":"prepl bound to *in* and *out*, suitable for use with e.g. server/repl (socket-repl).\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default identity)","row":132},{"fixed-arities":[1],"end-row":153,"meta":{},"name-end-col":21,"name-end-row":152,"name-row":152,"ns":"cljs.core.server","name":"clj-eval","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojurescript/blob/r1.11.60/src/main/clojure/cljs/core/server.clj#L152","filename":"/src/main/clojure/cljs/core/server.clj","macro":true,"col":3,"name-col":13,"end-col":27,"arglist-strs":["[form]"],"row":152}]