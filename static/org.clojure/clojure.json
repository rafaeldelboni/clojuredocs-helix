[{"author":"Stuart Sierra, Stuart Halloway, David Liebke","doc":"Clojure String utilities\n\nIt is poor form to (:use clojure.string). Instead, use require\nwith :as to specify a prefix, e.g.\n\n(ns your.namespace.here\n  (:require [clojure.string :as str]))\n\nDesign notes for clojure.string:\n\n1. Strings are objects (as opposed to sequences). As such, the\n   string being manipulated is the first argument to a function;\n   passing nil will result in a NullPointerException unless\n   documented otherwise. If you want sequence-y behavior instead,\n   use a sequence.\n\n2. Functions are generally not lazy, and call straight to host\n   methods where those are available and efficient.\n\n3. Functions take advantage of String implementation details to\n   write high-performing loop/recurs instead of using higher-order\n   functions. (This is not idiomatic in general-purpose application\n   code.)\n\n4. When a function is documented to accept a string argument, it\n   will take any implementation of the correct *interface* on the\n   host platform. In Java, this is CharSequence, which is more\n   general than String. In ordinary usage you will almost always\n   pass concrete strings. If you are doing something unusual,\n   e.g. passing a mutable implementation of CharSequence, then\n   thread-safety is your responsibility.","end-row":44,"filename":"clojure/string.clj","name":"clojure.string","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.string"},{"author":"Rich Hickey","doc":"Set operations such as union/intersection.","end-row":11,"filename":"clojure/set.clj","name":"clojure.set","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.set"},{"author":"Jason Sankey","doc":"clojure.test extension for JUnit-compatible XML output.\n\n  JUnit (http://junit.org/) is the most popular unit-testing library\n  for Java.  As such, tool support for JUnit output formats is\n  common.  By producing compatible output from tests, this tool\n  support can be exploited.\n\n  To use, wrap any calls to clojure.test/run-tests in the\n  with-junit-output macro, like this:\n\n    (use 'clojure.test)\n    (use 'clojure.test.junit)\n\n    (with-junit-output\n      (run-tests 'my.cool.library))\n\n  To write the output to a file, rebind clojure.test/*test-out* to\n  your own PrintWriter (perhaps opened using\n  clojure.java.io/writer).","end-row":39,"filename":"clojure/test/junit.clj","name":"clojure.test.junit","row":17,"ns":null,"var-definitions":"org.clojure/clojure/clojure.test.junit"},{"author":"Stuart Sierra","doc":"clojure.test extensions for the Test Anything Protocol (TAP)\n\n  TAP is a simple text-based syntax for reporting test results.  TAP\n  was originally developed for Perl, and now has implementations in\n  several languages.  For more information on TAP, see\n  http://testanything.org/ and\n  http://search.cpan.org/~petdance/TAP-1.0.0/TAP.pm\n\n  To use this library, wrap any calls to\n  clojure.test/run-tests in the with-tap-output macro,\n  like this:\n\n    (use 'clojure.test)\n    (use 'clojure.test.tap)\n\n    (with-tap-output\n     (run-tests 'my.cool.library))","end-row":43,"filename":"clojure/test/tap.clj","name":"clojure.test.tap","row":23,"ns":null,"var-definitions":"org.clojure/clojure/clojure.test.tap"},{"author":"Rich Hickey","doc":"Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet","end-row":16,"filename":"clojure/zip.clj","name":"clojure.zip","row":12,"ns":null,"var-definitions":"org.clojure/clojure/clojure.zip"},{"author":"Rich Hickey","doc":"Graphical object inspector for Clojure data structures.","end-row":17,"filename":"clojure/inspector.clj","name":"clojure.inspector","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.inspector"},{"author":"Rich Hickey","doc":"XML reading/writing.","end-row":13,"filename":"clojure/xml.clj","name":"clojure.xml","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.xml"},{"author":"Stuart Halloway","doc":"Reflection on Host Types\nAlpha - subject to change.\n\nTwo main entry points: \n\n* type-reflect reflects on something that implements TypeReference.\n* reflect (for REPL use) reflects on the class of an instance, or\n  on a class if passed a class\n\nKey features:\n\n* Exposes the read side of reflection as pure data. Reflecting\n  on a type returns a map with keys :bases, :flags, and :members.\n\n* Canonicalizes class names as Clojure symbols. Types can extend\n  to the TypeReference protocol to indicate that they can be\n  unambiguously resolved as a type name. The canonical format\n  requires one non-Java-ish convention: array brackets are <>\n  instead of [] so they can be part of a Clojure symbol.\n\n* Pluggable Reflectors for different implementations. The default\n  JavaReflector is good when you have a class in hand, or use\n  the AsmReflector for \"hands off\" reflection without forcing\n  classes to load.\n\nPlatform implementers must:\n\n* Create an implementation of Reflector.\n* Create one or more implementations of TypeReference.\n* def default-reflector to be an instance that satisfies Reflector.","end-row":42,"filename":"clojure/reflect.clj","name":"clojure.reflect","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.reflect"},{"author":"Stuart Halloway","doc":"Non-core data functions.","end-row":13,"filename":"clojure/data.clj","name":"clojure.data","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.data"},{"doc":"Functions to turn objects into data. Alpha, subject to change","end-row":11,"filename":"clojure/datafy.clj","name":"clojure.datafy","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.datafy"},{"author":"Stuart Sierra","doc":"Print stack traces oriented towards Clojure, not Java.","end-row":16,"filename":"clojure/stacktrace.clj","name":"clojure.stacktrace","row":14,"ns":null,"var-definitions":"org.clojure/clojure/clojure.stacktrace"},{"author":"Rich Hickey","doc":"DEPRECATED Wrapper of the ForkJoin library (JSR-166).","end-row":11,"filename":"clojure/parallel.clj","name":"clojure.parallel","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.parallel"},{"author":"Rich Hickey","doc":"edn reading.","end-row":12,"filename":"clojure/edn.clj","name":"clojure.edn","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.edn"},{"author":"Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, and Stuart Halloway","doc":"A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \"is\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \"abcde\" \"ab\"))\n\n   You can type an \"is\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \"expected:\" line shows you the original expression, and the\n   \"actual:\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \"false\" on the last line is the value returned from the\n   expression.  The \"is\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \"(is (thrown? c ...))\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \"is\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n   In addition, you can document groups of assertions with the\n   \"testing\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \"testing\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \"Arithmetic\"\n     (testing \"with positive integers\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \"with negative integers\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \"testing\" macro may only be used\n   INSIDE a \"deftest\" or \"with-test\" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The \"with-test\" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (= 4 (my-function 2 2)))\n     (is (= 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id=51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \"addition\" and \"subtraction\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \"Practical Common Lisp\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \"(arithmetic addition)\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function \"(run-tests namespaces...)\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \"arithmetic\" example above, you\n   probably do not want the \"addition\" and \"subtraction\" tests run\n   separately.  In that case, you must define a special function\n   named \"test-ns-hook\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable \"*load-tests*\" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by \"with-test\" or \"deftest\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  \"each\"\n   fixtures are run repeatedly, once for each test function created\n   with \"deftest\" or \"with-test\".  \"each\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \"each\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a \"once\" fixture, is only run once,\n   around ALL the tests in the namespace.  \"once\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \"once\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \"is\" macro by defining new\n   methods for the \"assert-expr\" multimethod.  These methods are\n   called during expansion of the \"is\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the \"report\" function: (report event)\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \"testing\" strings will be a list in \"*testing-contexts*\", and\n   the vars being tested will be a list in \"*testing-vars*\".\n\n   Your \"report\" function should wrap any printing calls in the\n   \"with-test-out\" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n","end-row":237,"filename":"clojure/test.clj","name":"clojure.test","row":17,"ns":null,"var-definitions":"org.clojure/clojure/clojure.test"},{"author":"Rich Hickey","doc":"The core Clojure language.","end-row":11,"filename":"clojure/core.clj","name":"clojure.core","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.core"},{"end-row":11,"filename":"clojure/instant.clj","name":"clojure.instant","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.instant"},{"end-row":9,"filename":"clojure/uuid.clj","name":"clojure.uuid","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.uuid"},{"author":"Christophe Grand","doc":"Start a web browser from Clojure","end-row":17,"filename":"clojure/java/browse.clj","name":"clojure.java.browse","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.java.browse"},{"author":"Christophe Grand","doc":"Helper namespace for clojure.java.browse.\n            Prevents console apps from becoming GUI unnecessarily.","end-row":13,"filename":"clojure/java/browse_ui.clj","name":"clojure.java.browse-ui","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.java.browse-ui"},{"author":"Stuart Sierra, Chas Emerick, Stuart Halloway","doc":"This file defines polymorphic I/O utility functions for Clojure.","end-row":22,"filename":"clojure/java/io.clj","name":"clojure.java.io","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.java.io"},{"author":"Chris Houser, Stuart Halloway","doc":"Conveniently launch a sub-process providing its stdin and\ncollecting its stdout","end-row":16,"filename":"clojure/java/shell.clj","name":"clojure.java.shell","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.java.shell"},{"author":"Christophe Grand, Stuart Sierra","doc":"A repl helper to quickly open javadocs.","end-row":14,"filename":"clojure/java/javadoc.clj","name":"clojure.java.javadoc","row":8,"ns":null,"var-definitions":"org.clojure/clojure/clojure.java.javadoc"},{"author":"Alex Miller","doc":"Clojure wrapper functions for java.lang.Math static methods.\n\n  Function calls are inlined for performance, and type hinted for primitive\n  long or double parameters where appropriate. In general, Math methods are\n  optimized for performance and have bounds for error tolerance. If\n  greater precision is needed, use java.lang.StrictMath directly instead.\n\n  For more complete information, see:\n  https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html","end-row":20,"filename":"clojure/math.clj","name":"clojure.math","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.math"},{"author":"Tom Faulhaber","doc":"A Pretty Printer for Clojure\n\nclojure.pprint implements a flexible system for printing structured data\nin a pleasing, easy-to-understand format. Basic use of the pretty printer is \nsimple, just call pprint instead of println. More advanced users can use \nthe building blocks provided to create custom output formats. \n\nOut of the box, pprint supports a simple structured format for basic data \nand a specialized format for Clojure source code. More advanced formats, \nincluding formats that don't look like Clojure data at all like XML and \nJSON, can be rendered by creating custom dispatch functions. \n\nIn addition to the pprint function, this module contains cl-format, a text \nformatting function which is fully compatible with the format function in \nCommon Lisp. Because pretty printing directives are directly integrated with\ncl-format, it supports very concise custom dispatch. It also provides\na more powerful alternative to Clojure's standard format function.\n\nSee documentation for pprint and cl-format for more information or \ncomplete documentation on the Clojure web site on GitHub.","end-row":39,"filename":"clojure/pprint.clj","name":"clojure.pprint","row":14,"ns":null,"var-definitions":"org.clojure/clojure/clojure.pprint"},{"author":"Chris Houser, Christophe Grand, Stephen Gilardi, Michel Salim","doc":"Utilities meant to be used interactively at the REPL","end-row":17,"filename":"clojure/repl.clj","name":"clojure.repl","row":11,"ns":null,"var-definitions":"org.clojure/clojure/clojure.repl"},{"author":"Stuart Sierra","doc":"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.","end-row":33,"filename":"clojure/walk.clj","name":"clojure.walk","row":21,"ns":null,"var-definitions":"org.clojure/clojure/clojure.walk"},{"author":"Stephen C. Gilardi and Rich Hickey","doc":"Top-level main function for Clojure REPL and scripts.","end-row":22,"filename":"clojure/main.clj","name":"clojure.main","row":11,"ns":null,"var-definitions":"org.clojure/clojure/clojure.main"},{"author":"Stuart Sierra","doc":"Macros that expand to repeated copies of a template expression.","end-row":28,"filename":"clojure/template.clj","name":"clojure.template","row":25,"ns":null,"var-definitions":"org.clojure/clojure/clojure.template"},{"author":"Rich Hickey","doc":"A library for reduction and parallel folding. Alpha and subject\n      to change.","end-row":15,"filename":"clojure/core/reducers.clj","name":"clojure.core.reducers","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.core.reducers"},{"author":"Alex Miller","doc":"Socket server support","end-row":19,"filename":"clojure/core/server.clj","name":"clojure.core.server","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.core.server"},{"end-row":9,"filename":"clojure/core/protocols.clj","name":"clojure.core.protocols","row":9,"ns":null,"var-definitions":"org.clojure/clojure/clojure.core.protocols"}]