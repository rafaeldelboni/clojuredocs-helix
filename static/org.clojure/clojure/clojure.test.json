[{"fixed-arities":[1],"end-row":687,"meta":{},"name-end-col":23,"index":0,"name-end-row":683,"private":true,"name-row":683,"added":"1.1","ns":"clojure.test","name":"default-fixture","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L683","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":8,"end-col":7,"arglist-strs":["[f]"],"doc":"The default, empty, fixture function.  Just calls its argument.","row":683},{"end-row":657,"meta":{},"name-end-col":19,"index":0,"name-end-row":648,"name-row":648,"added":"1.1","ns":"clojure.test","name":"set-test","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L648","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":60,"arglist-strs":["[name & body]"],"varargs-min-arity":1,"doc":"Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.","row":648},{"end-row":269,"meta":{},"name-end-col":34,"index":0,"name-end-row":269,"name-row":269,"ns":"clojure.test","name":"*testing-contexts*","defined-by":"clojure.core/def","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L269","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":16,"end-col":42,"row":269},{"fixed-arities":[0],"end-row":778,"meta":{},"name-end-col":16,"index":0,"name-end-row":768,"name-row":768,"added":"1.1","ns":"clojure.test","name":"run-tests","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L768","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":18,"arglist-strs":["[]","[& namespaces]"],"varargs-min-arity":0,"doc":"Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given.  Returns a map\n  summarizing test results.","row":768},{"fixed-arities":[1,2],"end-row":570,"meta":{},"name-end-col":13,"index":0,"name-end-row":554,"name-row":554,"added":"1.1","ns":"clojure.test","name":"is","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L554","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":39,"arglist-strs":["[form]","[form msg]"],"doc":"Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.","row":554},{"fixed-arities":[1],"end-row":830,"meta":{},"name-end-col":19,"index":0,"name-end-row":813,"name-row":813,"added":"1.11","ns":"clojure.test","name":"run-test","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L813","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":35,"arglist-strs":["[test-symbol]"],"doc":"Runs a single test.\n\n  Because the intent is to run a single test, there is no check for the namespace test-ns-hook.","row":813},{"fixed-arities":[1],"end-row":735,"meta":{},"name-end-col":16,"index":0,"name-end-row":723,"name-row":723,"added":"1.6","ns":"clojure.test","name":"test-vars","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L723","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":59,"arglist-strs":["[vars]"],"doc":"Groups vars by their namespace and runs test-var on them with\n  appropriate fixtures applied.","row":723},{"end-row":257,"meta":{},"name-end-col":21,"index":0,"name-end-row":257,"name-row":257,"added":"1.1","ns":"clojure.test","name":"*stack-trace-depth*","defined-by":"clojure.core/def","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L252","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":2,"end-col":26,"doc":"The maximum depth of stack traces to print when an Exception\n  is thrown during a test.  Defaults to nil, which means print the \n  complete stack trace.","row":252},{"end-row":595,"meta":{},"name-end-col":14,"index":0,"name-end-row":572,"name-row":572,"added":"1.1","ns":"clojure.test","name":"are","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L572","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":89,"arglist-strs":["[argv expr & args]"],"varargs-min-arity":2,"doc":"Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.","row":572},{"end-row":250,"meta":{},"name-end-col":15,"index":0,"name-end-row":250,"name-row":250,"added":"1.1","ns":"clojure.test","name":"*load-tests*","defined-by":"clojure.core/defonce","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L245","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":3,"end-col":21,"doc":"True by default.  If set to false, no test functions will\n   be created by deftest, set-test, or with-test.  Use this to omit\n   tests when compiling or loading production code.","row":245},{"fixed-arities":[1],"end-row":292,"meta":{},"name-end-col":20,"index":0,"name-end-row":282,"name-row":282,"added":"1.1","ns":"clojure.test","name":"file-position","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L282","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"deprecated":"1.2","name-col":7,"end-col":44,"arglist-strs":["[n]"],"doc":"Returns a vector [filename line-number] for the nth call up the\n  stack.\n\n  Deprecated in 1.2: The information needed for test reporting is\n  now on :file and :line keys in the result map.","row":282},{"fixed-arities":[1],"end-row":434,"meta":{},"name-end-col":16,"index":0,"name-end-row":424,"name-row":424,"added":"1.1","ns":"clojure.test","name":"function?","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L424","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":14,"arglist-strs":["[x]"],"doc":"Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).","row":424},{"fixed-arities":[1],"end-row":795,"meta":{},"name-end-col":18,"index":0,"name-end-row":789,"name-row":789,"added":"1.1","ns":"clojure.test","name":"successful?","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L789","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":36,"arglist-strs":["[summary]"],"doc":"Returns true if the given test summary indicates all tests\n  were successful, false otherwise.","row":789},{"end-row":267,"meta":{},"name-end-col":30,"index":0,"name-end-row":267,"name-row":267,"ns":"clojure.test","name":"*testing-vars*","defined-by":"clojure.core/def","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L267","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":16,"end-col":38,"row":267},{"fixed-arities":[1],"end-row":422,"meta":{},"name-end-col":31,"index":0,"name-end-row":416,"name-row":416,"added":"1.1","ns":"clojure.test","name":"get-possibly-unbound-var","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L416","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":16,"arglist-strs":["[v]"],"doc":"Like var-get but returns nil if the var is unbound.","row":416},{"end-row":637,"meta":{},"name-end-col":18,"index":0,"name-end-row":622,"name-row":622,"added":"1.1","ns":"clojure.test","name":"deftest","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L622","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":44,"arglist-strs":["[name & body]"],"varargs-min-arity":1,"doc":"Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.","row":622},{"fixed-arities":[2],"end-row":466,"meta":{},"name-end-col":17,"index":0,"name-end-row":455,"name-row":455,"added":"1.1","ns":"clojure.test","name":"assert-any","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L455","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":14,"arglist-strs":["[msg form]"],"doc":"Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.","row":455},{"fixed-arities":[2],"end-row":668,"meta":{},"name-end-col":19,"index":0,"name-end-row":663,"private":true,"name-row":663,"added":"1.1","ns":"clojure.test","name":"add-ns-meta","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L663","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":8,"end-col":37,"arglist-strs":["[key coll]"],"doc":"Adds elements in coll to the current namespace metadata as the\n  value of key.","row":663},{"fixed-arities":[2],"end-row":546,"meta":{},"name-end-col":19,"index":0,"name-end-row":538,"name-row":538,"added":"1.1","ns":"clojure.test","name":"try-expr","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L538","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":56,"arglist-strs":["[msg form]"],"doc":"Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.","row":538},{"fixed-arities":[0],"end-row":312,"meta":{},"name-end-col":27,"index":0,"name-end-row":307,"name-row":307,"added":"1.1","ns":"clojure.test","name":"testing-contexts-str","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L307","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":60,"arglist-strs":["[]"],"doc":"Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.","row":307},{"fixed-arities":[1],"end-row":320,"meta":{},"name-end-col":25,"index":0,"name-end-row":314,"name-row":314,"added":"1.1","ns":"clojure.test","name":"inc-report-counter","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L314","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":73,"arglist-strs":["[name]"],"doc":"Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.","row":314},{"end-row":675,"meta":{},"name-end-col":23,"index":0,"name-end-row":670,"name-row":670,"added":"1.1","ns":"clojure.test","name":"use-fixtures","defined-by":"clojure.core/defmulti","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L670","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":11,"end-col":43,"doc":"Wrap test runs in a fixture function to perform setup and\n  teardown. Using a fixture-type of :each wraps every test\n  individually, while :once wraps the whole run in a single function.","row":670},{"fixed-arities":[0,1],"end-row":787,"meta":{},"name-end-col":20,"index":0,"name-end-row":780,"name-row":780,"added":"1.1","ns":"clojure.test","name":"run-all-tests","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L780","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":82,"arglist-strs":["[]","[re]"],"doc":"Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.","row":780},{"fixed-arities":[1],"end-row":349,"meta":{},"name-end-col":32,"index":0,"name-end-row":344,"private":true,"name-row":344,"ns":"clojure.test","name":"stacktrace-file-and-line","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L344","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":8,"end-col":28,"arglist-strs":["[stacktrace]"],"row":344},{"end-row":619,"meta":{},"name-end-col":20,"index":0,"name-end-row":609,"name-row":609,"added":"1.1","ns":"clojure.test","name":"with-test","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L609","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":17,"arglist-strs":["[definition & body]"],"varargs-min-arity":1,"doc":"Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.","row":609},{"end-row":603,"meta":{},"name-end-col":18,"index":0,"name-end-row":597,"name-row":597,"added":"1.1","ns":"clojure.test","name":"testing","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L597","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":14,"arglist-strs":["[string & body]"],"varargs-min-arity":1,"doc":"Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).","row":597},{"end-row":265,"meta":{},"name-end-col":41,"index":0,"name-end-row":264,"name-row":264,"ns":"clojure.test","name":"*initial-report-counters*","defined-by":"clojure.core/def","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L264","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":16,"end-col":44,"row":264},{"end-row":278,"meta":{},"name-end-col":24,"index":0,"name-end-row":273,"name-row":273,"added":"1.1","ns":"clojure.test","name":"with-test-out","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L273","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":14,"arglist-strs":["[& body]"],"varargs-min-arity":0,"doc":"Runs body with *out* bound to the value of *test-out*.","row":273},{"fixed-arities":[1],"end-row":367,"meta":{},"name-end-col":16,"index":0,"name-end-row":351,"name-row":351,"added":"1.2","ns":"clojure.test","name":"do-report","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L351","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":9,"arglist-strs":["[m]"],"doc":"Add file and line information to a test result and call report.\n   If you are writing a custom assert-expr method, call this function\n   to pass test results to report.","row":351},{"fixed-arities":[1],"end-row":741,"meta":{},"name-end-col":20,"index":0,"name-end-row":737,"name-row":737,"added":"1.1","ns":"clojure.test","name":"test-all-vars","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L737","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":38,"arglist-strs":["[ns]"],"doc":"Calls test-vars on every var interned in the namespace, with fixtures.","row":737},{"fixed-arities":[2],"end-row":453,"meta":{},"name-end-col":23,"index":0,"name-end-row":436,"name-row":436,"added":"1.1","ns":"clojure.test","name":"assert-predicate","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L436","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":18,"arglist-strs":["[msg form]"],"doc":"Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).","row":436},{"fixed-arities":[2],"end-row":694,"meta":{},"name-end-col":23,"index":0,"name-end-row":689,"name-row":689,"added":"1.1","ns":"clojure.test","name":"compose-fixtures","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L689","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":32,"arglist-strs":["[f1 f2]"],"doc":"Composes two fixture functions, creating a new fixture function\n  that combines their behavior.","row":689},{"end-row":271,"meta":{},"name-end-col":26,"index":0,"name-end-row":271,"name-row":271,"ns":"clojure.test","name":"*test-out*","defined-by":"clojure.core/def","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L271","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":16,"end-col":33,"row":271},{"fixed-arities":[2],"end-row":342,"meta":{},"name-end-col":21,"index":0,"name-end-row":335,"private":true,"name-row":335,"ns":"clojure.test","name":"file-and-line","defined-by":"clojure.core/defn-","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L335","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"deprecated":"1.8","name-col":8,"end-col":31,"arglist-strs":["[exception depth]"],"row":335},{"end-row":645,"meta":{},"name-end-col":19,"index":0,"name-end-row":639,"name-row":639,"added":"1.1","ns":"clojure.test","name":"deftest-","defined-by":"clojure.core/defmacro","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L639","lang":[],"filename":"/src/clj/clojure/test.clj","macro":true,"col":1,"name-col":11,"end-col":44,"arglist-strs":["[name & body]"],"varargs-min-arity":1,"doc":"Like deftest but creates a private var.","row":639},{"end-row":481,"meta":{},"name-end-col":22,"index":0,"name-end-row":476,"name-row":476,"ns":"clojure.test","name":"assert-expr","defined-by":"clojure.core/defmulti","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L476","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":11,"end-col":24,"row":476},{"end-row":262,"meta":{},"name-end-col":33,"index":0,"name-end-row":262,"name-row":262,"ns":"clojure.test","name":"*report-counters*","defined-by":"clojure.core/def","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L262","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":16,"end-col":38,"row":262},{"end-row":333,"meta":{},"name-end-col":9,"index":0,"name-end-row":333,"name-row":333,"added":"1.1","ns":"clojure.test","name":"report","defined-by":"clojure.core/defmulti","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L324","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":3,"end-col":16,"doc":"Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.  See the documentation at\n   the top of test_is.clj for more information on the types of\n   arguments for 'report'.","row":324},{"fixed-arities":[1],"end-row":701,"meta":{},"name-end-col":20,"index":0,"name-end-row":696,"name-row":696,"added":"1.1","ns":"clojure.test","name":"join-fixtures","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L696","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":54,"arglist-strs":["[fixtures]"],"doc":"Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.","row":696},{"fixed-arities":[1],"end-row":721,"meta":{},"name-end-col":15,"index":0,"name-end-row":708,"name-row":708,"added":"1.1","ns":"clojure.test","name":"test-var","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L708","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":51,"arglist-strs":["[v]"],"doc":"If v has a function in its :test metadata, calls that function,\n  with *testing-vars* bound to (conj *testing-vars* v).","row":708},{"fixed-arities":[1],"end-row":811,"meta":{},"name-end-col":19,"index":0,"name-end-row":797,"name-row":797,"added":"1.11","ns":"clojure.test","name":"run-test-var","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L797","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":17,"arglist-strs":["[v]"],"doc":"Runs the tests for a single Var, with fixtures executed around the test, and summary output after.","row":797},{"fixed-arities":[1],"end-row":762,"meta":{},"name-end-col":14,"index":0,"name-end-row":743,"name-row":743,"added":"1.1","ns":"clojure.test","name":"test-ns","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L743","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":25,"arglist-strs":["[ns]"],"doc":"If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  Returns the final, dereferenced state of\n  *report-counters*.","row":743},{"fixed-arities":[1],"end-row":305,"meta":{},"name-end-col":23,"index":0,"name-end-row":294,"name-row":294,"added":"1.1","ns":"clojure.test","name":"testing-vars-str","defined-by":"clojure.core/defn","git-source":"https://github.com/clojure/clojure/blob/clojure-1.11.1/src/clj/clojure/test.clj#L294","lang":[],"filename":"/src/clj/clojure/test.clj","col":1,"name-col":7,"end-col":31,"arglist-strs":["[m]"],"doc":"Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.","row":294}]